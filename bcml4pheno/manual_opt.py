# AUTOGENERATED! DO NOT EDIT! File to edit: manual_opt.ipynb (unless otherwise specified).

__all__ = ['manual_significance', 'points2hrs', 'maxhrs2points', 'sig_grid']

# Cell
import numpy as np
import itertools

# Cell
def manual_significance(S,Bs,se,bes):
    """Returns signal significance given yield and efficiency for signal and background"""
    return (S * se) / np.sqrt(S * se + sum([B * be for B, be in zip(Bs, bes)]))

# Cell
def points2hrs(points, points2sec=126/(5**3 * 6)):
    """Returns number of hours required to compute significance for given number of points"""
    return points * points2sec * 3600**-1

# Cell
def maxhrs2points(maxhrs, points2sec=126/(5**3 * 6)):
    """Returns maximal number of points capable of being computed during a given number of hours"""
    return maxhrs * 3600 * points2sec**-1

# Cell
def sig_grid(signal, backgrounds, numS, numBs, cuts):
    """
    Computes signal significance for a high-dimensional grid of event selection criteria.

    Each row of cuts should take the form [index, isCutBelow, vals]
    where 'index' gives the index of the feature being cut on
    in the signal/background data, 'isCutBelow' is a boolean specifying
    if that variable should involve removing data points below (True) or
    above (False) the given values, and 'vals' is a list of values to cut at
    """

    indices = [row[0] for row in cuts]
    isCutBelows = [row[1] for row in cuts]
    points = list(itertools.product(*[row[-1] for row in cuts]))
    sigsize = len(signal)
    bgsizes = np.array([len(bg) for bg in backgrounds])
    sigs = []
    sigsizeprimes = []
    bgsizesprimes = []
    for point in points:
        sigsizeprime = np.count_nonzero(np.logical_and.reduce(
            np.array([np.where(signal[:,index] > val, isCutBelow, not isCutBelow)
                      for index, isCutBelow, val in zip(indices, isCutBelows, point)])))
        bgsizesprime = np.array([np.count_nonzero(np.logical_and.reduce(
            np.array([np.where(background[:,index] > val, isCutBelow, not isCutBelow)
                      for index, isCutBelow, val in zip(indices, isCutBelows, point)]))) for background in backgrounds])
        sigsizeprimes.append(sigsizeprime)
        bgsizesprimes.append(bgsizesprime)
        sigs.append(manual_significance(numS, numBs, sigsizeprime/sigsize, bgsizesprime/bgsizes))
    return [points, sigs, np.array(sigsizeprimes)/sigsize, np.array(bgsizesprimes)/bgsizes]